算法：有输入输出的、有限的、确定的、有效的过程
程序：实现算法的一种方式
算法设计：抽象为数学模型、写求解过程
随机算法：按照一定概率进行选择
描述：自然语言、流程图、程序语言、Pseudocode
算法评估：Empirical（实验结果->理论推导），Theoretical（算法效率：时间/空间）
	W(n)：最坏情况时间复杂度
	A(n)=∑P()*t：平均时间复杂度
基本运算的执行次数（加减、比较）
	时间复杂度：时间的函数表示基本运算 （I：输入规模 N：问题规模）
	复杂性的渐近性态：舍弃低阶项，不必考虑常数因子
	渐近上，下界记号：
		O（存在c与n0，使n>=n0都有f(n)<=c*g(n),则f(n)=O(g(n))（<=）
		/=最坏情况下时间复杂度（输入I相关）
		Ω（存在c与n0，使n>=n0都有f(n)>=c*g(n),则f(n)= Ω(g(n))（>=）
	紧渐近界限记号：Θ（c1，c2，n0被两个相似函数夹住）（=）
	非紧上，下界限：o（f(n)/g(n)->0），ω（f(n)/g(n)->∞）（<，>） 
Determinism（确定性算法）：每一步有确定选择
Polynomial（P类问题）：多项式时间内求解
Non- Determinism（非确定性算法）：穷举并用确定性算法验证
Non- Deterministic Polynomial Complete Problem（NPC NP完全问题）：NP问题可以归约至NPC问题
Non- Deterministic Polynomial Difficult Problem NP难问题：不一定为NP问题，NPC问题可归约到NP难问题（不一定在多项式时间内可验证）

	问题复杂度不会超过解决其的算法的复杂度
	判定问题（decision problem）：证明易于求解
判定形式的NP完全问题的最优化为NP难问题
TSP：时间复杂度n! 最优化：min{∑d（Ck,Ck+1）+d（Ck,C1）} （d（Ck,Ck+1）存在）

递归分治：
	分治：
		问题具有最优子结构性质（二分搜索）
		分解问题，解决小问题，合并，子问题相互独立（非独立则使用动态规划）
		分治：
	大整数乘法：
		X=a(n/2位)b(n/2位) Y=c(n/2位)d(n/2位)	
			XY=ac2^n+(ad + bc) *2^(n/2)+bd
			快速傅里叶变换
		Strassen矩阵乘法：
			将矩阵分为大小相等的子矩阵 ，使用分治法降阶求出子矩阵
			T(n)=8T(n/2)+O(n^2)
		排序问题：
			二分归并排序：划分，求解子问题，合并（时间复杂度O(n log n)，稳定	）
			快速排序：选择轴值与右指针，从右开始扫描，遇小交换，从左扫描（不	稳定）
递归：直/间接调用自身（终止，通项条件）

	双递归函数：Ackerman函数
	整数划分：q(n, m) m为最大加数
		1.	q(n, 1)=1 （n>=1）
		2.	q(n, m)=q(n, n) （m>=n）
		3.	q(n, n)=1+q(n,n-1)
		4.	q(n, m)=q(n-m, m)+1(n,m-1) (n>m>1)
	Hanoi塔：Hanoi(n, A, B, C)（从A利用B移到C）
		1.	n=1, move(A, C)
		2.	Hanoi(n-1, A, C, B)
		3.	Move(A, C)
		4.	Hanoi(n-1, B, A, C)
	递推方程：T（n）=2T（n-1）+1（终止条件：T(1)=1）
		迭代法求解（找出T(n)通项公式，数学归纳法验证正确性）
		换元迭代法：将n转换为变元K的递推，
		T(n)=4T(n/2)+O(n)
		T(n)=2T(n/2)+n-1，令n=2^k 
				T(n)=a*T(n/b)+f(n)
				公式：T(n)=n^(log b a)+∑a^ i f(n/b^ i )
			递归树验证换元迭代法：
				T(N)等于树上所有节点的值（非函数项）
				W(m)=（函数项）W(m1)+…+W(mk)+（节点值 非函数项）f(m)+…+g(m)
	主定理Master：T(n)=a*T(n/b)+f(n)
	1.	若f(n)阶小（<O(n^(log b^a))），则T（n）=Θ(n^(log b^a))
	2.	若与f(n)同阶（=O(n^(log b^a))），则T（n）=Θ(n^(log b^a) * logn)
	3.	若f(n)阶大，且a*f(n/b)≤c*f(n)（c<1），则T（n）=Θ(f(n))

动态规划：
	Dynamic Programming：重叠子问题，最优子结构性质,通过表记录已知结果，避免重复计算
		1.	建模，寻找目标函数与约束条件
		2.	分段，将问题分解为子问题，确定子问题边界
		3.	分析，原/子问题间依赖关系
		4.	判断，是否满足最优子结构性质
		5.	确定最小子问题初值，自底向上，利用已知结果简化计算选择向量


	通过表记录已知结果，避免重复计算
	最优化问题：解空间中满足约束条件的可行解中可使目标函数取得极值的解
	最优化原理：多段决策过程，每一阶段的决策依赖于前一阶段状态
	最优子结构：最大子问题的最优解包含其他子问题最优解
	找零问题：n张面值为pi的货币，找零A，使得零钱数量最少
		可行解满足：Σp=A
选择向量X=(x_1,x_2,x_3?x_n )，使得：∑x_i p_i=A，且d=min∑xi
	最短路径问题：
		子问题界定：后边界不变，前边界前移
		f(k_i )=min{k_i k_(i-1)+f(k_(i-1) )}
	设计要素：目标函数，约束条件，边界，递推方程，最优化原则，最小子问题界定
	矩阵连乘：加括号划分至只有两两连乘（简化矩阵连乘运算）
		A<i,j>，B<j,k> AB相乘共需ijk次运算
		穷举：
			T(n)=Ω(2^2n/n^(3/2) )指数级的时间复杂度
		递归：时间复杂度高，空间开销小
			将问题划分i~k与k~j两部分
			m[i,j]=(min)┬(?≤k<j)?{ m[i,k]+m[k+1,j]+p_(i-1) p_k p_j}
			T(n)=∑(T(k)+T(n-k)+O(1))≥O(n)+2∑T(k)
			T(n)=Ω(2^(n-1))由于进行了重复计算，仍然为指数型
		迭代：时间复杂度低，空间消耗多
			保存子问题的解结果并标记决策（m 子问题最少次数，s 划分方式k的值）
	确定链长r 1~n
	左右边界i，j
	遍历确定划分位置k，
 t=m[i,k]+m[k+1,j]+〖(子矩阵相乘)p〗_(i-1) p_k p_j
	更新解 m[i, j]=t
时间复杂度：T(n)=O(n^3 )（三次O(n)循环，n^2个备忘录一个O(n)）
		动态规划时间复杂度：备忘录计算+各项合并时间
	最长公共子序列：
		子序列：从给定序列中按序任意选出一段
		Longest Common Subsequence：序列X，Y的最长的相同子序列
		穷举：2^m个子序列，共〖O(n2〗^m)
		DP：
			构造解O(m*n)，追踪解O(m+n)
			空间复杂度O(m*n)
			1.	i=0/j=0，C[i, j]=0(设置初值C[i, j]=0)
			2.	若Xn=Yn， Zk为Xn-1与Yn-1的LCS+1
			3.	若Xn≠Yn，Zk=max{ C[i, j-1]，C[i-1, j] }
			标记函数B[i, j]，左上 I（LCS+1）/左 ← (C[i, j-1])/上↑(C[i-1, j])
	背包问题KP：
		填表O(n*b)（伪多项式时间算法b为常数：输入规模n, logb，O( n*2^k)）
		约束条件∑wi*xi≤b（最大重量）
		物品(vi, wi) 使∑vi*xi最大
		线性规划：目标函数与约束条件为线性函数
			F_k (y)=max?{F_(k-1) (y),F_k (y-w_k )+v_k}
			K=1时，Fk(y)初值为y/w_k向下取整
贪心算法：
	最优子结构，贪心选择性质
	Greedy Algorithm：每步选择均为局部最优选择（最优解的近似解）
	选择性质：整体最优可通过局部最优得到，自顶向下
	背包问题：
		一般背包（物品数可为小数）：每次均装入性价比最大的
		0-1背包（物品为整数）：贪心无法保证背包装满，闲置空间使价值降低
	活动选择问题：
		N个活动集合，s_i 〖/f〗_i 开始/结束时间
	截止时间排序，选取第一个
	遍历比较，若f_1≤s_i选取n_i
证明：
	K=1，假设存在j≠1的活动为A的第一个活动，用1替换必定满足
	K=n→K=n+1，假设对前K=n为真，证明K+1为真
	最优装载问题：
		装载能力C，无体积限制（0-1背包子问题）
		策略：轻者优先
正确性证明：
	数学归纳法：
第一数归：归纳基础（P(1)为真），归纳步骤（假设P(n)为真，证明P(n+1)真）p(n)→p(n+1)
第二数归：归纳基础（P(1)为真），归纳步骤（假设P(1,2…n)为真，证明P(n+1)真）P(1)∩P(2)∩?P(n)→P(n+1)
		描述与自然数n有关命题，证明第一个命题成立然后利用数归证明贪心正确
	二元前缀码：
		0-1代码表示字符，字符代码不能为其它前缀
		Huffman哈夫曼树：选取频率最小字符并形成子根，构建向上构建树
	最小生成树：n阶联通图G的生成树T无环且含n-1条边
		Prim算法：选取结点S{1}，while(V!=S)选取到集合S距离最小的顶点j加入S (更新维护堆O(logn)) （运行n-1次，每次执行O(n),T(n)=O(nlogn)）（点少适用）
		Kruskal算法：排序并选择最小边，判断不形成回路则加入（并查集：更新父结点，若两结点根节点相同，则不能将它们连接）T(n)=O(mlogm)（边少适用）
	单源最短路径：带权有向图，选取原点到其它所有点的最短路径
		Dijkstra算法：S=s{u}，S=V时结束，维护节点到S最短路径dist[i]，选取dist中最小的j加入S并修改dist

	多机调度问题NPC：使用贪心近似求解
	近似比：Ap=  (A())/(Ope())（贪心策略/最优策略，取及差下限）

回溯Backtracking：
	组织解空间，跳跃性穷举（找出所有解，比较得出最优解）
	条件：多米诺性质（?p(x_1 x_2?x_k )→?p(x_1 x_2?x_(k+1) )）进行减枝
	深度/宽度优先搜索，满足（扩张解向量，继续搜索），不满足（回溯至父节点）
	显约束（解空间），隐约束（约束条件）
		4皇后问题：解向量〖<x〗_1,x_2,x_3 〖,x〗_4>（使用n叉树表示解空间）〖O(n〗^n)
		0-1背包问题：bool 〖<x〗_1,x_2,…x_i> 表示是否选择物品，子集树含〖O(2〗^n)片树叶
旅行商问题：<k1,k2…,ki>城市排列，O(n!)个节点的排列树
min?{∑_(i=1)^n?〖?(k_(i-1),k_i )}〗+?(k_i,k_1 )  
	递归：
	确定Xi初始取值
	计算满足约束的分支Sk
	遍历解空间Sk，取出最大节点
	If(k==n) 〖<x〗_1,x_2,…x_k>为解，否则goto 2
迭代：
	If(k>n) 〖<x〗_1,x_2,…x_k>为解
	遍历Sk，计算Sk+1并调用ReBack(k+1)（跳跃性：递归调用，保存现场）
ReBack（沿右分支遍历向左，遇右遍历右分支，遇根停止）

轮船载重问题：装入第一艘船，使其剩余空间尽量少 (O(2^n ))
	遍历wi，若满足x[i]置1，否则置0
	记录当前best
	回溯（沿着右分支向上回溯，直到发现为左分支再向右回溯（至根停止））
图着色问题：解空间（m叉树，一个节点有m种可能着色方案）(O(〖n*m〗^n ))
	每个节点选取可能颜色，若不满足则回溯

分支限界
	以广度/最小耗费优先方式搜索解空间（根据限界函数调整搜索，细粒度的回溯）
	队列式，栈式优先节点
	代价函数：子树区域内所有可行解的上界（极大化 初值为0）（极小化相反）
	界：已知最大可行解
		背包问题：代价函数（已装入价值+Δ（剩余背包*可行最大性价比））
		0-1背包：代价函数高方向搜索（广度优先 使最先找出的界最优）
		非对称TSP：优先访问当前最低+未选城市的最低出发票价之和（最小化问题）
	分布式计算不同分支

