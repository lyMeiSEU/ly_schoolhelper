算法：有输入输出的、有限的、确定的、有效的过程
程序：实现算法的一种方式
算法设计：抽象为数学模型、写求解过程
随机算法：按照一定概率进行选择
描述：自然语言、流程图、程序语言、Pseudocode
算法评估：Empirical（实验结果->理论推导），Theoretical（算法效率：时间/空间）
	W(n)：最坏情况时间复杂度
	A(n)=∑P()*t：平均时间复杂度
基本运算的执行次数（加减、比较）
	时间复杂度：时间的函数表示基本运算 （I：输入规模 N：问题规模）
	复杂性的渐近性态：舍弃低阶项，不必考虑常数因子
	渐近上，下界记号：
		O（存在c与n0，使n>=n0都有f(n)<=c*g(n),则f(n)=O(g(n))（<=）
		/=最坏情况下时间复杂度（输入I相关）
		Ω（存在c与n0，使n>=n0都有f(n)>=c*g(n),则f(n)= Ω(g(n))（>=）
	紧渐近界限记号：Θ（c1，c2，n0被两个相似函数夹住）（=）
	非紧上，下界限：o（f(n)/g(n)->0），ω（f(n)/g(n)->∞）（<，>） 
Determinism（确定性算法）：每一步有确定选择
Polynomial（P类问题）：多项式时间内求解
Non- Determinism（非确定性算法）：穷举并用确定性算法验证
Non- Deterministic Polynomial Complete Problem（NPC NP完全问题）：NP问题可以归约至NPC问题
Non- Deterministic Polynomial Difficult Problem NP难问题：不一定为NP问题，NPC问题可归约到NP难问题（不一定在多项式时间内可验证）

	问题复杂度不会超过解决其的算法的复杂度
	判定问题（decision problem）：证明易于求解
判定形式的NP完全问题的最优化为NP难问题
TSP：时间复杂度n! 最优化：min{∑d（Ck,Ck+1）+d（Ck,C1）} （d（Ck,Ck+1）存在）

递归分治：
	分治：
		问题具有最优子结构性质（二分搜索）
		分解问题，解决小问题，合并，子问题相互独立（非独立则使用动态规划）
		分治：
	大整数乘法：
		X=a(n/2位)b(n/2位) Y=c(n/2位)d(n/2位)	
			XY=ac2^n+(ad + bc) *2^(n/2)+bd
			快速傅里叶变换
		Strassen矩阵乘法：
			将矩阵分为大小相等的子矩阵 ，使用分治法降阶求出子矩阵
			T(n)=8T(n/2)+O(n^2)
		排序问题：
			二分归并排序：划分，求解子问题，合并（时间复杂度O(n log n)，稳定	）
			快速排序：选择轴值与右指针，从右开始扫描，遇小交换，从左扫描（不	稳定）
递归：直/间接调用自身（终止，通项条件）

	双递归函数：Ackerman函数
	整数划分：q(n, m) m为最大加数
		1.	q(n, 1)=1 （n>=1）
		2.	q(n, m)=q(n, n) （m>=n）
		3.	q(n, n)=1+q(n,n-1)
		4.	q(n, m)=q(n-m, m)+1(n,m-1) (n>m>1)
	Hanoi塔：Hanoi(n, A, B, C)（从A利用B移到C）
		1.	n=1, move(A, C)
		2.	Hanoi(n-1, A, C, B)
		3.	Move(A, C)
		4.	Hanoi(n-1, B, A, C)
	递推方程：T（n）=2T（n-1）+1（终止条件：T(1)=1）
		迭代法求解（找出T(n)通项公式，数学归纳法验证正确性）
		换元迭代法：将n转换为变元K的递推，
		T(n)=4T(n/2)+O(n)
		T(n)=2T(n/2)+n-1，令n=2^k 
				T(n)=a*T(n/b)+f(n)
				公式：T(n)=n^(log b a)+∑a^ i f(n/b^ i )
			递归树验证换元迭代法：
				T(N)等于树上所有节点的值（非函数项）
				W(m)=（函数项）W(m1)+…+W(mk)+（节点值 非函数项）f(m)+…+g(m)
	主定理Master：T(n)=a*T(n/b)+f(n)
	1.	若f(n)阶小（<O(n^(log b^a))），则T（n）=Θ(n^(log b^a))
	2.	若与f(n)同阶（=O(n^(log b^a))），则T（n）=Θ(n^(log b^a) * logn)
	3.	若f(n)阶大，且a*f(n/b)≤c*f(n)（c<1），则T（n）=Θ(f(n))

动态规划：
	Dynamic Programming：重叠子问题，最优子结构性质,通过表记录已知结果，避免重复计算
		1.	建模，寻找目标函数与约束条件
		2.	分段，将问题分解为子问题，确定子问题边界
		3.	分析，原/子问题间依赖关系
		4.	判断，是否满足最优子结构性质
		5.	确定最小子问题初值，自底向上，利用已知结果简化计算选择向量


	通过表记录已知结果，避免重复计算
	最优化问题：解空间中满足约束条件的可行解中可使目标函数取得极值的解
	最优化原理：多段决策过程，每一阶段的决策依赖于前一阶段状态
	最优子结构：最大子问题的最优解包含其他子问题最优解
	找零问题：n张面值为pi的货币，找零A，使得零钱数量最少
		可行解满足：Σp=A
选择向量X=(x_1,x_2,x_3?x_n )，使得：∑x_i p_i=A，且d=min∑xi
	最短路径问题：
		子问题界定：后边界不变，前边界前移
		f(k_i )=min{k_i k_(i-1)+f(k_(i-1) )}
	设计要素：目标函数，约束条件，边界，递推方程，最优化原则，最小子问题界定
	矩阵连乘：加括号划分至只有两两连乘（简化矩阵连乘运算）
		A<i,j>，B<j,k> AB相乘共需ijk次运算
		穷举：
			T(n)=Ω(2^2n/n^(3/2) )指数级的时间复杂度
		递归：时间复杂度高，空间开销小
			将问题划分i~k与k~j两部分
			m[i,j]=(min)┬(?≤k<j)?{ m[i,k]+m[k+1,j]+p_(i-1) p_k p_j}
			T(n)=∑(T(k)+T(n-k)+O(1))≥O(n)+2∑T(k)
			T(n)=Ω(2^(n-1))由于进行了重复计算，仍然为指数型
		迭代：时间复杂度低，空间消耗多
			保存子问题的解结果并标记决策（m 子问题最少次数，s 划分方式k的值）
	确定链长r 1~n
	左右边界i，j
	遍历确定划分位置k，
 t=m[i,k]+m[k+1,j]+〖(子矩阵相乘)p〗_(i-1) p_k p_j
	更新解 m[i, j]=t
时间复杂度：T(n)=O(n^3 )（三次O(n)循环，n^2个备忘录一个O(n)）
		动态规划时间复杂度：备忘录计算+各项合并时间
	最长公共子序列：
		子序列：从给定序列中按序任意选出一段
		Longest Common Subsequence：序列X，Y的最长的相同子序列
		穷举：2^m个子序列，共〖O(n2〗^m)
		DP：
			构造解O(m*n)，追踪解O(m+n)
			空间复杂度O(m*n)
			1.	i=0/j=0，C[i, j]=0(设置初值C[i, j]=0)
			2.	若Xn=Yn， Zk为Xn-1与Yn-1的LCS+1
			3.	若Xn≠Yn，Zk=max{ C[i, j-1]，C[i-1, j] }
			标记函数B[i, j]，左上 I（LCS+1）/左 ← (C[i, j-1])/上↑(C[i-1, j])
	背包问题KP：
		填表O(n*b)（伪多项式时间算法b为常数：输入规模n, logb，O( n*2^k)）
		约束条件∑wi*xi≤b（最大重量）
		物品(vi, wi) 使∑vi*xi最大
		线性规划：目标函数与约束条件为线性函数
			F_k (y)=max?{F_(k-1) (y),F_k (y-w_k )+v_k}
			K=1时，Fk(y)初值为y/w_k向下取整
贪心算法：
	最优子结构，贪心选择性质
	Greedy Algorithm：每步选择均为局部最优选择（最优解的近似解）
	选择性质：整体最优可通过局部最优得到，自顶向下
	背包问题：
		一般背包（物品数可为小数）：每次均装入性价比最大的
		0-1背包（物品为整数）：贪心无法保证背包装满，闲置空间使价值降低

		

